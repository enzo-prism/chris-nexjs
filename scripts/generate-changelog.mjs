import { execSync } from "node:child_process";
import { writeFileSync } from "node:fs";
import { resolve } from "node:path";

const DEFAULT_REPOS =
  "enzo-prism/chris-dentist@main|Legacy Website, enzo-prism/chris-nexjs@main|Current Website";
const REPO_DEFINITIONS = (process.env.CHANGELOG_REPOS || DEFAULT_REPOS)
  .split(",")
  .map((item) => item.trim())
  .filter(Boolean);

const CHANGELOG_LIMIT = Number(process.env.CHANGELOG_LIMIT || "0");
const OUTPUT_FILE =
  process.env.CHANGELOG_OUTPUT ||
  resolve(process.cwd(), "client", "src", "data", "changelog.ts");

function parseRepoDefinitions() {
  return REPO_DEFINITIONS.map((entry) => {
    const [repoWithBranch, label] = entry.split("|");
    const [repo, branch = "main"] = repoWithBranch.split("@");
    return {
      repo: repo.trim(),
      branch: branch.trim(),
      label: (label || repo).trim(),
    };
  }).filter((item) => item.repo);
}

function normalizeType(message) {
  const conventionalMatch = message.match(/^([a-zA-Z]+)(\([^)]+\))?:\s*(.*)$/);
  if (
    conventionalMatch &&
    ["feat", "fix", "docs", "perf"].includes(conventionalMatch[1].toLowerCase())
  ) {
    return conventionalMatch[1].toLowerCase();
  }

  const firstWordMatch = message.match(/^([a-zA-Z]+)/);
  if (
    firstWordMatch &&
    ["feat", "fix", "docs", "perf"].includes(firstWordMatch[1].toLowerCase())
  ) {
    return firstWordMatch[1].toLowerCase();
  }

  return "update";
}

function removeConventionalPrefix(message) {
  return message
    .replace(/^[a-zA-Z]+(\([^)]+\))?:\s*/, "")
    .replace(/^feat\b\s*:?\s*/i, "")
    .replace(/^fix\b\s*:?\s*/i, "")
    .replace(/^docs\b\s*:?\s*/i, "")
    .replace(/^perf\b\s*:?\s*/i, "")
    .replace(/^chore\b\s*:?\s*/i, "");
}

function toTitleCase(value) {
  const trimmed = value.trim();
  if (!trimmed) return "";
  return `${trimmed.charAt(0).toUpperCase()}${trimmed.slice(1)}`;
}

function cleanCommitMessage(message) {
  const firstLine = message.split("\n")[0].trim();
  if (!firstLine) {
    return "Website update";
  }

  if (firstLine.toLowerCase().startsWith("published your app")) {
    return "Deployment checkpoint created from previous website workflow";
  }

  return firstLine;
}

function buildSummary(type, message) {
  const normalized = removeConventionalPrefix(message).trim();
  const plainMessage = toTitleCase(normalized || "Website update");
  if (type === "fix") {
    return `${toTitleCase(plainMessage.replace(/^Fix\s+/i, ""))}.`;
  }
  return `${plainMessage}.`;
}

function buildTitle(message) {
  const title = cleanCommitMessage(message).trim();
  if (!title) return "Website update";
  const normalized = removeConventionalPrefix(title).trim();
  return (normalized.charAt(0).toUpperCase() + normalized.slice(1)) || "Website update";
}

function parseDate(value) {
  const parsed = new Date(value);
  if (Number.isNaN(parsed.valueOf())) {
    return null;
  }
  return parsed;
}

function getCommitDate(commit) {
  return (
    parseDate(commit.commit?.author?.date)?.toISOString() ??
    parseDate(commit.commit?.committer?.date)?.toISOString() ??
    "1970-01-01T00:00:00.000Z"
  );
}

function fetchCommitsForRepo(config) {
  const response = execSync(
    `gh api "repos/${config.repo}/commits?sha=${encodeURIComponent(
      config.branch,
    )}&per_page=100" --paginate --jq '.[] | @json'`,
    { encoding: "utf8" },
  );

  const rawLines = response
    .trim()
    .split(/\r?\n/)
    .filter((line) => line.length > 0);

  return rawLines.map((line) => {
    const commit = JSON.parse(line);
    return {
      ...commit,
      sourceRepo: config.label,
    };
  });
}

function formatEntries(commits) {
  return commits.map((commit) => {
    const rawMessage = commit.commit?.message || "";
    const cleanedMessage = cleanCommitMessage(rawMessage);
    const type = normalizeType(rawMessage);
    const normalizedTitle = buildTitle(cleanedMessage);
    const commitDate = getCommitDate(commit);

    return {
      date: commitDate.split("T")[0],
      commitDate,
      type: type === "feat" ? "feature" : type === "fix" ? "fix" : "update",
      title: normalizedTitle,
      summary: buildSummary(type, cleanedMessage),
      sha: commit.sha.slice(0, 8),
      commitUrl: commit.html_url,
      source: commit.sourceRepo,
    };
  });
}

function writeOutput(entries) {
  const payload =
    "// This file is generated by scripts/generate-changelog.mjs using GitHub CLI.\n\nexport type ChangelogEntry = {\n  readonly date: string;\n  readonly type: \"feature\" | \"fix\" | \"update\";\n  readonly title: string;\n  readonly summary: string;\n  readonly sha: string;\n  readonly commitUrl: string;\n  readonly commitDate: string;\n  readonly source: string;\n};\n\nexport const changelogEntries: readonly ChangelogEntry[] = " +
    `${JSON.stringify(entries, null, 2)} as const;\n`;
  writeFileSync(OUTPUT_FILE, payload, "utf8");
}

function run() {
  const repos = parseRepoDefinitions();
  const combinedCommits = repos.flatMap(fetchCommitsForRepo);

  const sortedEntries = formatEntries(combinedCommits)
    .sort((a, b) => (a.commitDate < b.commitDate ? 1 : a.commitDate > b.commitDate ? -1 : 0))
    .slice(0, Math.max(0, CHANGELOG_LIMIT) || undefined);

  writeOutput(sortedEntries);
  console.log(
    `Generated ${sortedEntries.length} changelog entries to ${OUTPUT_FILE}`,
  );
}

run();
